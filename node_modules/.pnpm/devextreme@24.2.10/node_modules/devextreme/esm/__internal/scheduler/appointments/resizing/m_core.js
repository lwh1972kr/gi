/**
 * DevExtreme (esm/__internal/scheduler/appointments/resizing/m_core.js)
 * Version: 24.2.10
 * Build date: Fri Aug 29 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    dateUtilsTs
} from "../../../core/utils/date";
import {
    dateUtils
} from "../../../core/utils/m_date";
const toMs = dateUtils.dateToMilliseconds;
const getCellData = function(_ref, cellRowIndex, cellColumnIndex, isOccupiedAllDay) {
    let {
        viewDataProvider: viewDataProvider
    } = _ref;
    let isAllDay = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let rtlEnabled = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : false;
    const cellData = viewDataProvider.getCellData(cellRowIndex, cellColumnIndex, isOccupiedAllDay, rtlEnabled);
    if (!isAllDay) {
        cellData.endDate = dateUtilsTs.addOffsets(cellData.startDate, [toMs("day")])
    }
    return cellData
};
const getAppointmentLeftCell = options => {
    const {
        cellHeight: cellHeight,
        cellWidth: cellWidth,
        relativeAppointmentRect: relativeAppointmentRect,
        appointment: appointment,
        rtlEnabled: rtlEnabled
    } = options;
    const cellRowIndex = Math.floor(relativeAppointmentRect.top / cellHeight);
    const cellColumnIndex = Math.round(relativeAppointmentRect.left / cellWidth);
    return getCellData(options, cellRowIndex, cellColumnIndex, appointment.isOccupiedAllDay, appointment.isAllDay, rtlEnabled)
};
const getDateRangeHorizontal = options => {
    const {
        cellWidth: cellWidth,
        cellCountInRow: cellCountInRow,
        relativeAppointmentRect: relativeAppointmentRect,
        appointment: appointment,
        handles: handles
    } = options;
    const appointmentFirstCell = getAppointmentLeftCell(options);
    const appointmentCellsAmount = Math.round(relativeAppointmentRect.width / cellWidth);
    const appointmentLastCellIndex = appointmentFirstCell.index + (appointmentCellsAmount - 1);
    if (handles.left) {
        return {
            startDate: appointmentFirstCell.startDate,
            endDate: appointmentFirstCell.startDate > appointment.endDate ? appointmentFirstCell.startDate : appointment.endDate
        }
    }
    const appointmentRowIndex = Math.floor(appointmentLastCellIndex / cellCountInRow);
    const appointmentColumnIndex = appointmentLastCellIndex % cellCountInRow;
    const appointmentLastCell = getCellData(options, appointmentRowIndex, appointmentColumnIndex, appointment.isOccupiedAllDay, appointment.isAllDay);
    const {
        endDate: endDate
    } = appointmentLastCell;
    return {
        startDate: endDate < appointment.startDate ? endDate : appointment.startDate,
        endDate: endDate
    }
};
const getDateRangeHorizontalRTL = options => {
    const {
        cellCountInRow: cellCountInRow,
        appointment: appointment,
        handles: handles,
        cellWidth: cellWidth,
        relativeAppointmentRect: relativeAppointmentRect
    } = options;
    const appointmentLastCell = getAppointmentLeftCell(options);
    if (handles.right) {
        const appointmentLastCellIndex = appointmentLastCell.index;
        const appointmentCellsAmount = Math.round(relativeAppointmentRect.width / cellWidth);
        const appointmentFirstCellIndex = appointmentLastCellIndex - appointmentCellsAmount + 1;
        const appointmentRowIndex = Math.floor(appointmentLastCellIndex / cellCountInRow);
        const appointmentFirstCell = getCellData(options, appointmentRowIndex, appointmentFirstCellIndex, appointment.isOccupiedAllDay, appointment.isAllDay);
        return {
            startDate: appointmentFirstCell.startDate,
            endDate: appointmentFirstCell.startDate > appointment.endDate ? appointmentFirstCell.startDate : appointment.endDate
        }
    }
    const {
        endDate: endDate
    } = appointmentLastCell;
    return {
        startDate: endDate < appointment.startDate ? endDate : appointment.startDate,
        endDate: endDate
    }
};
const getRelativeAppointmentRect = (appointmentRect, parentAppointmentRect) => {
    const left = appointmentRect.left - parentAppointmentRect.left;
    const top = appointmentRect.top - parentAppointmentRect.top;
    const width = left < 0 ? appointmentRect.width + left : appointmentRect.width;
    const height = top < 0 ? appointmentRect.height + top : appointmentRect.height;
    return {
        left: Math.max(0, left),
        top: Math.max(0, top),
        width: width,
        height: height
    }
};
const getAppointmentCellsInfo = options => {
    const {
        appointmentSettings: appointmentSettings,
        isVerticalGroupedWorkSpace: isVerticalGroupedWorkSpace,
        DOMMetaData: DOMMetaData
    } = options;
    const DOMMetaTable = appointmentSettings.allDay && !isVerticalGroupedWorkSpace ? [DOMMetaData.allDayPanelCellsMeta] : DOMMetaData.dateTableCellsMeta;
    const {
        positionByMap: positionByMap
    } = appointmentSettings;
    const {
        height: cellHeight,
        width: cellWidth
    } = DOMMetaTable[positionByMap.rowIndex][positionByMap.columnIndex];
    const cellCountInRow = DOMMetaTable[positionByMap.rowIndex].length;
    return {
        cellWidth: cellWidth,
        cellHeight: cellHeight,
        cellCountInRow: cellCountInRow
    }
};
export const getAppointmentDateRange = options => {
    const {
        appointmentSettings: appointmentSettings
    } = options;
    const relativeAppointmentRect = getRelativeAppointmentRect(options.appointmentRect, options.parentAppointmentRect);
    const cellInfo = getAppointmentCellsInfo(options);
    const appointment = {
        startDate: appointmentSettings.info.sourceAppointment.startDate,
        endDate: appointmentSettings.info.sourceAppointment.endDate,
        isAllDay: Boolean(appointmentSettings.info.appointment.allDay),
        isOccupiedAllDay: Boolean(appointmentSettings.allDay)
    };
    const extendedOptions = _extends({}, options, cellInfo, {
        appointment: appointment,
        relativeAppointmentRect: relativeAppointmentRect
    });
    return !options.rtlEnabled ? getDateRangeHorizontal(extendedOptions) : getDateRangeHorizontalRTL(extendedOptions)
};
